# 이터레이터

## pointer

-   prev, next로 현재는 어디고 다음이 어딘지를 가리키는 pointer가 존재. -> 더 쓸모 있는 객체!

-   객체의 키값으면 정수를 주면 이터

## 이터레이터 vs 이터레이블

이터레이터 프로토콜 // next()를 호출하면 value, done을 가진 이터레이터 리터럴을 반환한다.
이터러블 프로토콜 // 함수명 Symbol.iterator를 구현/상속한 메소드 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.

## typeof obj[Symbol.interator] === 'function'

### 이터레이터 프로토콜을 준수한다?

-   return되는 값이 value와 done인 next 함수가 있는 객체라는 뜻.

## 이터레이터엔 length가 있을 수 있고, 없을 수 있다

## string은 왜 이터레이터일까?

-   실제로 V8 엔진에서 string은 4byte가 넘어가면 컨스탄트 풀에 저장되는데, heap으로 저장된다.

## for of vs for in

in은 키를 모두 가져와서 순회하고, of는 이터레이터에만 적용되는 것으로 하나씩 다음 차례를 가져오면서 순회한다.

## 언제 이터레이터가 필요할까?

엄청 큰 데이터를 하나씩 하나씩 담거나 줄 때 필요하다.

ex) 무한 스크롤 만들 때, 새로운 컨텐츠(피드)를 한번에 받아야 할때, 200개를 받아온다고 하면 한번에 받아올 필요없이
스크롤할 때마다 5개씩 받아오고, 또 스크롤하면 5개씩 받아오고 할 수 있다.

그런데 직접 만드는게 쉽지 않다. 그래서 있는 것이 제네레이터다.(async await)

## Event Driven 방식으로 작동하는 Node.js

-   백그라운드에 있는 web API가 있다. I/O를 커널에게 맡겨서 시작, 그 동안 스레드는 다른 일을 처리한다.커널에서 처리한 후 스레드한테 인터럽터를 전달한다.
-   이걸로 서로 다른 영역이어도 메시지를 주고받을 수 있다. (이것을 구현한게 socket io)

-   그런데 비동기랑 다르게, 제네레이터는 시그널(인터럽터)를 받기 전까진 홀트되어 있다. next()함수가 호출되면 그제서야 홀트가 풀리고 진행된다.
-   awiat을 안 쓰고 fetch를 하면 백그라운드에 들어가고 promise를 반환한다. 그런데 await을 쓰면 멈췄다가 response가 오면 그제야 다음 next()를 시작한다. 즉, 백그라운드에서 처리가 되어 next()를 호출하는 콜백이 실행됏을때 비로소 다음 코드가 실행된다. 이게 바로 async await작동 방식.

## linked list 자료구조와 iterator는 똑같다

-   slide210에 예시를 보면 실제 메모리에서는 value1의 rest는 value2, value2의 rest는 value3 이렇게 하나씩 가리키고 있을 거다.
-   즉, linked(=여기서는 rest)로 서로 연결이 되엉 ㅣㅆ기 때문에 linked list, 없다면 그냥 array..?
-
-   list의 역방향은 array?
