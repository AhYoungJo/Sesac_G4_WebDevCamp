## 전역 실행 컨텍스트

### 1. 전역 실행 컨텍스트

<p align="center">🔻</p> 

### 2. 전역 렉시컬 환경 (전역 실행 컨텍스트에 바인딩)
- 렉시컬 환경을 이루는 컴포넌트 (2)
1. 환경 레코드(Environment Record):
   - 스코프에 포함된 식별자를 등록하고, 등록된 식별자에 바인딩된 값을 관리하는 저장소
   - 전역 렉시컬 환경의 환경 레코드 = 전역 환경 레코드
  
    **전역 환경 레코드가 제공하는 것 (3)**
    - 전역 변수를 관리하는 스코프
    - 전역 객체 (빌트인 전역 프로퍼티, 빌트인 전역 메서드)
    - 표준 빌트인 객체

    **🥹과거?**
    - 전역 객체가 환경 레코드 역할을 맡았었음. ( 이 모든 것을 관리)
  
    **😀현재?**
    - var키워드로 선언한 변수 & let, const 키워드로 선언한 변수를 구분해서 관리하기 위해 전역 변수를 관리하는 스코프를 새롭게 만듬
    - 전역 스코프를 관리하는 레코드로는 2개가 있음
  
    **전역 스코프 역할을 하는 전역 환경 레코드 2가지**
    1. 객체 환경 레코드(Object Environment Record)가 관리하는 4가지:
        - var 키워드로 선언한 전역 변수
        - 함수 선언문으로 정의한 전역 함수
        - 빌트인 전역 프로퍼티와 빌트인 전역 함수(메서드)
        - 표준 빌트인 객체 
            
        - var 키워드로 선언한 전역 변수 & 함수 선언문으로 정의한 전역 함수 각각은 어떻게 전역 객체의 프로퍼티와 메서드가 되는 걸까? 그리고 전역 객체를 가리키는 식별자(window)없이도 전역 객체의 프로퍼티를 참조할 수 있는 걸까?
  
        > 💡객체 환경 레코드에 BindingObject라는 것이 연결되어 있는데, 이 곳에 있는 전역 객체에 var 키워드로 선언한 전역 변수와 전역 함수들이 전역 객체의 프로퍼티와 메서드가 저장된다.

        > 💡이렇게 등록된 애들을 식별자를 통해 검색하는데, 이때 '객체 환경 레코드'에서 검색해 반환한다. 

        - 아래 예제의 경우엔, 전역 변수 x와 함수 foo는 객체 환경 레코드를 통해 객체 환경 레코드의 BindingObject에 바인딩되어 있는 전역 객체의 프로퍼티와 메서드로 저장된다.
        - 그리고 이때 x라는 식별자는 키로 등록되고, undefined를 바인딩한다. (선언과 초기화가 동시 진행된다.)
        - 함수 foo는 똑같은 이름의 키가 전역 객체에 저장되고, 그 키에 생성된 함수 객체가 바로 할당한다.
        - so, 둘 다 코드 실행문 이전에 참조할 수 있음 (비록 값은 undefined로 나오겠지만), 이렇게 선두로 끌어올려진 것처럼 보이는 '변수 호이스팅', '함수 호이스팅'이 발생하게 되는 것!
     
        ```javascript
        //예제
        var x = 1
        const y = 2;
        
        function foo () {
            //...
        }
        ```
        (스택 자료 사진 넣기)
    
    **전역 객체를 가리키는 this의 바인딩은 어떻게?**
    - this 바인딩은 두 환경 레코드에 포함되어 있지 않고, 전역 환경 레코드의 [[GLobalThisValue]]에 바인딩됨. 
    - 전역 코드에서 this는 일반적으로 전역 객체 (브라우저는 window)를 가리키기 때문에 저기에 바인딩되어 있는 this의 값은 전역 객체임. (so, 전역 객체가 전역 환경 레코드의 [[GLobalThisValue]] 내부슬롯 안에 바인딩되어 있다고도 볼 수 있음)


    2. 선언적 환경 레코드(Declarative Environment Record)는?
        - let, const 키워드로 선언한 전역 변수를 등록하고 관리함
        - 얘네는 전역 객체에 저장되지 않고, 개념적인 블록 내에 저장됨
        - 그래서 window.y처럼 전역 객체 프로퍼티로 참조할 수 없음

        **🥹개념적인 블록??**
        - 개념적인 블록 === 전역 환경 레코드의 선언적 환경 레코드 그 자체!!
        
        - let, const 키워드는 선언과 초기화가 각각 **분리**돼서 실행됨
        - 둘다 코드 실행 전에 렉시컬 환경에 등록되기 때문에 **변수 호이스팅이 발생하긴 하지만**....
        - **코드가 실행되기 전까지**는, `<uninitialized>`가 바인딩되고, **일시적 사각지대에 빠지게 돼서 참조가 불가능하다**!😀
        
        (실행 컨텍스트 자료 사진 넣기)

2. 외부 참조에 대한 레코드(OuterLexicalEnvironmentReference):
   - 상위 스코프, 즉 자신이 참조하고 있는 상위 코드의 렉시컬 환경
   - 전역 렉시컬 환경을 포함하는 렉시컬 환경은 없기 때문에 전역 렉시컬 환경의 외부 렉시컬 환경에는 null이 할당됨


<div align="center">🔻</div> 

### 3. 전역 코드 실행

- 전역 변수 값이 할당되고, 함수 호출문을 실행
- 이때 식별자 검색은 실행 중인 실행 컨텍스트에서 검색하기 시작하다가 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 즉 상위 스코프로 이동해서 검색함 (=스코프 체인)
- 검색에 실패하면 참조 에러 발생

<div align="center">🔻</div> 

### 4. 함수 코드 평가 (예제에선 foo 함수 평가)

- 함수가 호출되면 해당 함수로 코드 제어권이 이동하고 해당 함수 코드를 평가
- 함수또한 초반에 함수의 실행 컨텍스트가 초기에 생성한 후 함수 렉시컬 환경을 생성한다.
- 함수의 렉시컬 환경 구성 또한 전역 렉시컬 환경의 구성에서 함수로 바뀐것 말고는 차이가 별로 없다.
- 함수의 렉시컬 환경까지 생성이 완료된 후 함수의 실행 컨텍스트가 스택에 쌓인다. (가장 최상위에 쌓이는데, 현재 실행중인 실행 컨텍스트라고도 할 수 있다.)
  
**함수 렉시컬 환경 생성 순서:**
  1. **함수 환경 레코드 생성**
    - 매개 변수, arguments 객체, 함수 내부 지역 변수, 중첩 함수를 등록 & 관리 
  2. **this 바인딩**
    - 함수 환경 레코드의 `[[ThisValue]]` 내부슬롯에 전역 객체를 가리키는 this가 바인딩 됨 (foo함수 예제를 기반으로 설명하는거라서, foo함수는 현재 일반 함수로 호출중, 만약 **일반 함수가 아니라 생성자 함수로 호출했다면 인스턴스를 가리키는 this가 바인딩** 되겠지?)
  
  (this바인딩까지 완료된 foo함수 렉시컬 환경 예제 이미지 추가하기)

  3. **외부 렉시컬 환경에 대한 참조 결정**
    - 함수가 평가되고 있는 시점에 실행 중인 실행 컨텍스트가 할당됨
    - 예제의 경우엔 foo라는 전역 함수가 평가되고 있는 시점에 실행되고 있는 실행 컨텍스트는 전역 실행 컨텍스트이기 때문에 전역 실행 컨텍스트가 할당됨
    - 더 정확하게는, 함수가 참조하고 있는 외부 렉시컬 환경에 대한 정보는 함수 객에의 내부 슬롯`[[Environment]]`에 저장되어 있어서, 함수의 외부 렉시컬 환경에 대한 참조에는 `[[Environment]]`에 저장된 렉시컬 환경의 참조가 바인딩되는 것임
    - 함수 객체의 `[[Environment]]`와 렉시컬 스코프는 클로저를 이해하는 중요한 단서!


<div align="center">🔻</div> 

### 5. 함수 코드 실행 (예제에선 foo 함수 실행)
- 변수 할당문 실행으로 지역 변수 x, y에 값이 할당되는데, 이떄 현재 실행중인 실행 컨텍스트부의 렉시컬 환경에서부터 식별자를 검색해나간다. 만약 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없다면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동해서 식별자를 검색한다. 즉, 상위 스코프로 이동해서 검색한다.
  > 현재 실행 중인 실행 컨텍스트는 foo 함수 실행 컨텍스트이므로 foo 함수의 렉시컬 환경에서 검색한다. 해당 예제에선 모두 검색이 가능하기 때문에 현재 실행 컨텍스트 내에서 검색 후 값을 할당하게 된다.

(foo 함수 코드 실행 도식도 추가하기, page380)


<div align="center">🔻</div> 

### 6. (만약 있다면) 중첩 함수 코드 평가 (예제에선 bar 함수 코드 평가)

- 실행 과정은 상위 함수 코드 평가와 동일하다.
(bar 함수 코드 실행 도식도, page 381)


<div align="center">🔻</div> 

### 7. 중첩 함수 코드 실행

- 일반적으로는 상위 함수 코드 실행 과정과 동일하다.
- `🌟스포크 체인이 발동하는 경우🌟` like.`console.log()`는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작해 외부 렉시컬 환경에 대한 참조로 이어진다. `console.log()`는 `전역 객체의 프로토타입`으로 스코프 체인 상의 상위 스코프, 그 중에서도 최상위 스코프인 전역 렉시컬 환경(전역 렉시컬 환경의 객체 환경 레코드의 BindingBoject)으로 이동해서 `console`식별자를 찾고 `console`객체에서 `log`메서드를 검색한다. 그리고선 `console.log`의 인수로 전달한 값을 평가 & 생성 후 `console`의 `log`메서드에 전달해 호출한다.

<div align="center">🔻</div> 

### 8. 중첩 함수 코드 실행 종료

- 실행 중인 중첩 함수의 실행 컨텍스트가 스택에서 `pop`되고, 현재 실행 중인 실행 컨텍스트는 상위 합수의 실행 컨텍스트가 된다.
- 💡**누군가에 의해 참조되고 있지 않다면**💡가비지 컬렉터에 의해 메모리 공간의 확보가 해제된다.
- 💡**만약 참조되고 있다면**💡소멸하지 않고 독립적인 객체로서 메모리에 존재하게 된다.

(bar함수 콛 실행 종료 도식도 추가, page385)

<div align="center">🔻</div> 

### 9. 상위 함수 코드 실행 종료

<div align="center">🔻</div>

### 10. 전역 코드 실행 종료
- 스택이 완전히 비워진다.

<br/>

## 실행 컨텍스트와 블록 레벨 스코프

- let과 const는 var과 달리 모든 코드 블록을 지역 스코프로 인정한다.(=블록 레벨 스코프) 어떻게 블록 레벨 스코프를 인정할까?

(page387 이미지)

- 만약 let/const로 변수를 선언하면 for, if 등과 같은 코드들의 스코프를 생성해야 하므로 블록 렉시컬 환경이 새로 생성되고, **전역 실행 컨텍스트의 렉시컬 환경**은 블록 렉시컬 환경으로 교체된다.
- 블록 렉시컬 환경은 let/const 키워드로 선언한 변수를 저장하는 선언적 환경 레코드와 연결되어 생성된다.
- for문처럼 반복해서 실행되는 코드 블록의 경우엔, 코드 블록이 1회 실행하고 다음 반복문을 실행할 때까지 값을 유지해야 하므로 반복적으로 실행될때마다 독립적인 렉시컬 환경을 생성한다.

-----
다음 내용은 이어서 클로저에서....